#define _GNU_SOURCE
#include <GraphBLAS.h>
#include <arpa/inet.h>
#include <ctype.h>
#include <fcntl.h>
#include <malloc.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <netinet/udp.h>
#include <openssl/aes.h>
#include <openssl/err.h>
#include <openssl/evp.h>
#include <pcap.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <time.h>
#include <unistd.h>
#include <zlib.h>

#include "cryptopANT.h"

// If at first you don't succeed, just abort.
#define LAGRAPH_TRY_EXIT(method)                                                                                       \
    {                                                                                                                  \
        GrB_Info info = (method);                                                                                      \
        if (!(info == GrB_SUCCESS))                                                                                    \
        {                                                                                                              \
            fprintf(stderr, "LAGraph error: [%d]\nFile: %s Line: %d\n", info, __FILE__, __LINE__);                     \
            exit(5);                                                                                                   \
        }                                                                                                              \
    }

struct posix_tar_header
{                       /* byte offset */
    char name[100];     /*   0 */
    char mode[8];       /* 100 */
    char uid[8];        /* 108 */
    char gid[8];        /* 116 */
    char size[12];      /* 124 */
    char mtime[12];     /* 136 */
    char chksum[8];     /* 148 */
    char typeflag;      /* 156 */
    char linkname[100]; /* 157 */
    char magic[6];      /* 257 */
    char version[2];    /* 263 */
    char uname[32];     /* 265 */
    char gname[32];     /* 297 */
    char devmajor[8];   /* 329 */
    char devminor[8];   /* 337 */
    char prefix[155];   /* 345 */
                        /* 500 */
    char padding1[12];  /* 512 */
};

#define TMAGIC   "ustar" /* ustar and a null */
#define TMAGLEN  6
#define TVERSION "00" /* 00 and no null */
#define TVERSLEN 2

struct _serialized_blob
{
    void *blob_data;
    GrB_Index blob_size;
};

int cidr2ipmask(const char *cidr, uint32_t *ip, uint32_t *mask);
int bloblist_to_tar(struct _serialized_blob *bloblist, const char *filename_prefix, unsigned int nvals);

int main(int argc, char *argv[])
{
    GrB_Matrix Gmat;
    GrB_Descriptor desc    = NULL;
    void *blob             = NULL;
    char anonkey[PATH_MAX] = { 0 }, prefix[128] = { 0 };
    GrB_Index blob_size = 0;
    char *line = NULL;
    size_t len = 0;
    ssize_t read;
    int swapped = 0, anonymize = 0;
    struct _serialized_blob *blob_list;
    FILE *fp;
    int c, nfiles = 0, nlines = 0;

    if (argc < 2)
    {
        fprintf(stdout, "usage: %s [-S] [-a cryptopan.key] [-n prefix] <file1.txt> ... <fileN.txt>\n", argv[0]);
        fprintf(stdout, "Input files should be newline-delimited lists of CIDR prefixes (e.g. 1.2.3.4/8)\n");
        fprintf(stdout, "    -S Produce big-endian (network byte order) output.\n");
        fprintf(stdout, "    -a Anonymize using CryptopANT (https://ant.isi.edu/software/cryptopANT/index.html)\n");
        fprintf(stdout, "       Requires a key generated by this library.\n");
        fprintf(stdout, "    -n Change the output filename prefix.  Default is LocalIPList-#FILES.tar\n");
        return 1;
    }

    while ((c = getopt(argc, argv, "Sa:n:")) != -1)
    {
        switch (c)
        {
            case 'a':
                anonymize = 1;
                snprintf(anonkey, sizeof(anonkey), "%s", optarg);
                break;
            case 'S':
                swapped = 1;
                break;
            case 'n':
                if (optarg && strlen(optarg) > 1)
                {
                    snprintf(prefix, sizeof(prefix) - 1, "%s", optarg);
                }
                else
                {
                    snprintf(prefix, sizeof(prefix) - 1, "LocalIPList");
                }
                break;
            case '?':
                if (optopt == 'a')
                {
                    fprintf(stderr, "Option -%c requires an argument.\n", optopt);
                }
                else if (isprint(optopt))
                {
                    fprintf(stderr, "Unknown option: -%c.\n", optopt);
                }
                else
                {
                    fprintf(stderr, "Unrecognized option: -%c.\n", optopt);
                }
                exit(1);
            default:
                exit(2);
        }
    }

    if (prefix[0] == '\0')
    {
        snprintf(prefix, sizeof(prefix) - 1, "LocalIPList");
    }

    if (anonymize != 0)
    {
        fprintf(stderr, "anonymizing using scramble keyfile: %s\n", anonkey);
        if (scramble_init_from_file(anonkey, SCRAMBLE_BLOWFISH, SCRAMBLE_BLOWFISH, NULL) < 0)
        {
            fprintf(stderr, "scramble_init_from_file(): nope\n");
            return 1;
        }
    }

    GrB_init(GrB_NONBLOCKING);
    nfiles    = argc - optind;
    blob_list = malloc(sizeof(struct _serialized_blob) * nfiles);

    for (int index = optind, blob_index = 0; index < argc; index++, blob_index++)
    {
        LAGRAPH_TRY_EXIT(GrB_Matrix_new(&Gmat, GrB_UINT32, 4294967296, 4294967296));

        if ((fp = fopen(argv[index], "r")) == NULL)
        {
            perror("fopen");
            exit(2);
        }

        while ((read = getline(&line, &len, fp)) != -1)
        {
            uint32_t network, start, end, mask;

            char *orig                  = strdup(line);
            orig[strcspn(orig, "\r\n")] = 0;

            nlines++;

            if (strchr(line, ':') != NULL) // Handle input of the type 10.0.0.0:10.255.255.255
            {
                struct in_addr ip_start, ip_end;
                char *ptr = strtok(line, ":");

                if (ptr == NULL)
                {
                    fprintf(stderr, "Malformed input on line %d: %s.\n", nlines, orig);
                    return 1;
                }

                if (inet_aton(ptr, &ip_start) == 0)
                {
                    fprintf(stderr, "Malformed input on line %d: %s.\n", nlines, orig);
                    return 1;
                }
                else
                {
                    start = ntohl(ip_start.s_addr);
                }

                ptr = strtok(NULL, ":");
                if (ptr == NULL)
                {
                    fprintf(stderr, "Malformed input on line %d: %s.\n", nlines, orig);
                    return 1;
                }

                if (inet_aton(ptr, &ip_end) == 0)
                {
                    fprintf(stderr, "Malformed input on line %d: %s.\n", nlines, orig);
                    return 1;
                }
                else
                {
                    end = ntohl(ip_end.s_addr);
                }
            }
            else // Handle input of the type 10.0.0.0/8
            {
                if (cidr2ipmask(line, &network, &mask) == -1)
                {
                    fprintf(stderr, "Malformed input on line %d: %s.\n", nlines, orig);
                    return 1;
                }

                start = network & mask;
                end   = start | ~mask;
            }

            if (start > end)
            {
                fprintf(stderr, "IP range contains no IP addresses on line %d: %s.\n", nlines, orig);
                return 1;
            }

            for (uint32_t i = start; i <= end; i++)
            {
                uint32_t new_ip = swapped ? htonl(i) : i;

                if (anonymize)
                {
                    if (swapped)
                    {
                        new_ip = scramble_ip4(new_ip, 16);
                    }
                    else
                    {
                        new_ip = ntohl(scramble_ip4(htonl(new_ip), 16));
                    }
                }

                GrB_Matrix_setElement(Gmat, 1, new_ip, new_ip);
            }
            free(orig);
        }
        fclose(fp);

        LAGRAPH_TRY_EXIT(GxB_Matrix_serialize(&blob, &blob_size, Gmat, desc));
        GxB_print(Gmat, 2);

        blob_list[blob_index].blob_data = blob;
        blob_list[blob_index].blob_size = blob_size;

        GrB_Matrix_free(&Gmat);
    }

    bloblist_to_tar(blob_list, prefix, nfiles);
}

/// @brief Convert a pointer array of struct _serialized_blob to a tar file, and save it to disk.
/// @param bloblist Pointer to array of struct _serialized_blob
/// @param filename_prefix Filename prefix to use - suffix will be -$nvals.tar
/// @param nvals Number of serialized GraphBLAS objects in the pointer array.
/// @return
int bloblist_to_tar(struct _serialized_blob *bloblist, const char *filename_prefix, unsigned int nvals)
{
    char f_name[PATH_MAX];
    int fd;

    snprintf(f_name, sizeof(f_name) - 1, "%s-%d.tar", filename_prefix, nvals);

    if ((fd = open(f_name, O_CREAT | O_WRONLY | O_TRUNC, 0660)) != -1)
    {
        size_t offset                     = 0;
        const unsigned char padblock[512] = { 0 };

        for (int i = 0; i < nvals; i++)
        {
            struct posix_tar_header th = { 0 }; // let's make a tar file, or close enough
            fprintf(stderr, "Packing #%d - blob size %ld\n", i, bloblist[i].blob_size);
            fflush(stderr);

            const unsigned char *th_ptr = (const unsigned char *)&th;
            size_t tmp_chksum           = 0;
            size_t aligned;

            sprintf(th.name, "%d.grb", i);
            sprintf(th.uid, "%06o ", 0);
            sprintf(th.gid, "%06o ", 0);
            sprintf(th.size, "%011o", (unsigned int)bloblist[i].blob_size);
            sprintf(th.mode, "%06o", 0644);
            sprintf(th.magic, "%s", TMAGIC);
            sprintf(th.mtime, "%011o", (unsigned int)time(NULL));
            th.typeflag = '0';
            memset(th.chksum, ' ', 8); // or checksum computed below will be wrong!

            for (int b = 0; b < sizeof(struct posix_tar_header); b++)
                tmp_chksum += th_ptr[b];

            sprintf(th.chksum, "%06o ", (unsigned int)tmp_chksum);

            if (write(fd, &th, sizeof(th)) != sizeof(th))
            {
                perror("write tar error: header");
                exit(4);
            }

            if (write(fd, bloblist[i].blob_data, bloblist[i].blob_size) != bloblist[i].blob_size)
            {
                perror("write tar error: blob");
                exit(4);
            }

            offset += sizeof(th) + bloblist[i].blob_size;
            aligned = offset % 512; // pad output file to 512 byte alignment
            if (aligned != 0)
            {
                if (write(fd, padblock, 512 - aligned) != 512 - aligned)
                {
                    perror("write tar error: padding");
                    exit(4);
                }
                offset += 512 - aligned;
            }
        }
        close(fd);
    }
    else
    {
        perror("open");
        return 1;
    }

    for (int i = 0; i < nvals; i++)
    {
        free(bloblist[i].blob_data);
    }

    free(bloblist);
    return 0;
}

/// @brief Convert an IPv4 string in CIDR notation into an IP address and subnet mask, both uint32_t
/// @param cidr CIDR string to parse (1.2.3.4/8)
/// @param ip IP address as unsigned integer
/// @param mask Subnet mask as unsigned integer
/// @return 1 on success, -1 on error.
int cidr2ipmask(const char *cidr, uint32_t *ip, uint32_t *mask)
{
    uint8_t a, b, c, d, bits;

    if (sscanf(cidr, "%hhu.%hhu.%hhu.%hhu/%hhu", &a, &b, &c, &d, &bits) < 5)
        return -1;

    if (bits > 32)
        return -1;

    *ip   = (a << 24UL) | (b << 16UL) | (c << 8UL) | (d);
    *mask = (0xFFFFFFFFUL << (32 - bits)) & 0xFFFFFFFFUL;

    return 1;
}
